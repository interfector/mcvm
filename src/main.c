#include <mcvm.h>
#include <sys/stat.h>
#include <unistd.h>

unsigned char assembly_code[] = {
/*	0xb3, 0x02,
	0xb2, 0x03,
	0x90,
	0x90,
	0x90,
	0xeb, 0x0d,
	0xb8, 0x01, 0x02, 0x03, 0x04,
	0x66, 0xb9, 0x01, 0x2,
	0x89, 0xc3,
	0x89, 0xca,
	0xb8, 0x01, 0x00, 0x00, 0x00,
	0x89, 0x08 
	0xb8, 0x01, 0x02, 0x03, 0x04,
	0xb1, 0x05,
	0xb8, 0x01, 0x00, 0x00, 0x00,
	0x89, 0x08,
	0x40, 0x41,
	0xb8, 0x00, 0x00, 0x00, 0x00,
	0xb9, 0x01, 0x00, 0x00, 0x00,
	0x8b, 0x08,
	0x89, 0x08,
	0xb8, 0x01, 0x02, 0x03, 0x04,
	0x81, 0xe8, 0x01, 0x02, 0x03, 0x04,
	0xb8, 0x02, 0x00, 0x00, 0x00,
	0xb9, 0x05, 0x00, 0x00, 0x00,
	0xf7, 0xe1,
	0xb8, 0x01, 0x02, 0x00, 0x00,
	0xb9, 0x01, 0x00, 0x00, 0x00,
	0x03, 0x41, 0x05
	0xb8, 0x01, 0x00, 0x00, 0x00,
	0xb9, 0x02, 0x00, 0x00, 0x00,
	0x01, 0x08,
	0x01, 0xc8,
	0xb8, 0x01, 0x00, 0x00, 0x00,
	0xb9, 0x08, 0x00, 0x00, 0x00,
	0x29, 0x48, 0x04, 
	0xb0, 0x00,
	0x80, 0xf8, 0x01,
	0xb0, 0x01,
	0xc6, 0x00, 0x2,
	0xb8, 0x00, 0x00, 0x00, 0x00,
	0xb9, 0x02, 0x00, 0x00, 0x00,
	0x89, 0x48, 0x03
	0xb8, 0x00, 0x00, 0x00, 0x00,
	0x8a, 0x08,
	0x80, 0xf9, 0xb9
	0xb8, 0x02, 0x00, 0x00, 0x00,
	0x8a, 0x48, 0x03,
	0x81, 0xf9, 0x80, 0x00, 0x00, 0x00
	0xb8, 0x04, 0x03, 0x02, 0x01,
	0x66, 0xb8, 0x02, 0x01,*/
	0x90
};

int
main(int argc, char** argv)
{
	asm_env* env = malloc( sizeof(asm_env) );
	struct assembly opcode = { 0, 0, 0, NULL };
	unsigned char* args;
	int i;

	FILE* fp;
	struct stat st;

	for(i = 0;i < R_REGS;i++)
		env->regs[ i ] = 0;

	env->eflags =
	env->current_op = 
	env->current_args = 0;

	/*
	env->mem_size = sizeof( assembly_code );
	env->mem_base = malloc( env->mem_size );

	memset( env->mem_base, 0x00, env->mem_size );
	memcpy( env->mem_base, assembly_code, sizeof(assembly_code) );
	*/

	if(!argv[1])
	{
		printf("Usage: %s <file>\n", argv[0]);
		return 1;
	}

	if(!(fp = fopen(argv[1], "r")))
		pdie("fopen", 2);

	if(stat(argv[1], &st) < 0)
		pdie("stat", 3);

	env->mem_size = (int) st.st_size;
	env->mem_base = malloc( env->mem_size + STACKSTART );
	memset( env->mem_base, 0x00, env->mem_size + STACKSTART );

	env->regs[ R_EBP ] = env->regs[ R_ESP ] = (unsigned int)STACKSTART;
	env->regs[ R_ESP ] += 4; /* - */

	if(fread(env->mem_base, 1, env->mem_size, fp) != env->mem_size)
		pdie("fread", 4);

	fclose( fp );

	env->mem_size += (STACKSTART + STACKSIZE);

	if(getenv("LIBSYSCALL"))
		loadHandler();

	for(env->eip = 0;env->eip < env->mem_size;env->eip++)
	{
		env->current_op = env->mem_base[ env->eip ];
		opcode = getOpcode( env->mem_base[ env->eip ] );

		if( !opcode.function )
			die( env, "SIGILL" );

		if( opcode.bytes > 0 )
		{
			env->current_args = 0;
			args = malloc( opcode.bytes );
			memcpy( args, env->mem_base + env->eip + 1, opcode.bytes);

			for(i = 0;i < opcode.bytes;i++)
				env->current_args |= (args[i] << (i * 8));
		}

		opcode.function( env );

		env->eip += opcode.bytes;
	}

	env->eip -= (opcode.bytes + 1);

	dumpAll( env );

	free( env );

	return 0;
}
